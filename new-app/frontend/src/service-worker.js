/* eslint-disable no-restricted-globals */
/* eslint-disable no-undef */

// This service worker can be customized!
// See https://developers.google.com/web/tools/workbox/modules
// for the list of available workbox modules, or add any other
// code you'd like.

import { clientsClaim } from 'workbox-core';
import { precacheAndRoute } from 'workbox-precaching';

// Dichiarazione di clients come proprietà globale
self.clients = self.clients;

// Precache all of the assets generated by your build process.
// Their URLs are injected into the manifest variable below.
// This variable must be present somewhere in your service worker file,
// even if you decide not to use precaching. See https://cra.link/PWA
precacheAndRoute(self.__WB_MANIFEST);

self.addEventListener('push', (event) => {
  console.log('Push ricevuto:', event);

  let data;
  try {
    data = event.data.json();
  } catch (e) {
    // Se non è JSON, prova a interpretare come testo
    console.log('Non è stato possibile interpretare il push come JSON:', e);
    const text = event.data.text();
    data = {
      title: 'Notifica CinfoEat',
      body: text,
      icon: '/favicon.ico'
    };
  }

  console.log('Dati notifica:', data);

  const options = {
    body: data.body,
    icon: data.icon || '/favicon.ico',
    badge: '/favicon.ico',
    data: {
      url: data.url || '/',
    },
    tag: 'cinfoeat-notification', // Tag per raggruppare le notifiche
    renotify: true // Notifica l'utente anche se c'è già una notifica con lo stesso tag
  };

  console.log('Opzioni notifica:', options);

  event.waitUntil(
    self.registration.showNotification(data.title, options)
      .then(() => {
        console.log('Notifica mostrata con successo');
      })
      .catch(error => {
        console.error('Errore nel mostrare la notifica:', error);
      })
  );
});

self.addEventListener('notificationclick', (event) => {
  console.log('Notifica cliccata:', event.notification);
  event.notification.close();

  // Apri una finestra specifica quando l'utente clicca sulla notifica
  event.waitUntil(
    clients.matchAll({ type: 'window' }).then((clientList) => {
      const url = event.notification.data.url;
      console.log('Apertura URL:', url);
      
      // Controlla se c'è già una finestra/tab aperta
      for (let i = 0; i < clientList.length; i++) {
        const client = clientList[i];
        if (client.url === url && 'focus' in client) {
          console.log('Finestra esistente trovata, focus su di essa');
          return client.focus();
        }
      }
      
      // Altrimenti, apri una nuova finestra/tab
      if (clients.openWindow) {
        console.log('Apertura nuova finestra');
        return clients.openWindow(url);
      }
    })
  );
});

// Precaching
self.addEventListener('install', (event) => {
  console.log('Service worker: installazione');
  // Attiva immediatamente il nuovo service worker senza aspettare che quello vecchio termini
  self.skipWaiting();
  
  event.waitUntil(
    caches.open('cinfoeat-v1').then((cache) => {
      return cache.addAll([
        '/',
        '/index.html',
        '/static/js/main.chunk.js',
        '/static/js/0.chunk.js',
        '/static/js/bundle.js',
        '/manifest.json',
        '/favicon.ico'
      ]);
    })
  );
});

self.addEventListener('activate', (event) => {
  console.log('Service worker: attivazione');
  // Rivendica il controllo su tutte le pagine client
  event.waitUntil(clients.claim());
  
  // Rimuovi le vecchie cache
  event.waitUntil(
    caches.keys().then((cacheNames) => {
      return Promise.all(
        cacheNames
          .filter((cacheName) => cacheName !== 'cinfoeat-v1')
          .map((cacheName) => caches.delete(cacheName))
      );
    })
  );
});

// Intercetta le richieste di rete e servi dalla cache quando possibile
self.addEventListener('fetch', (event) => {
  // Non intercettare le richieste API
  if (event.request.url.includes('/api/')) {
    return;
  }
  
  event.respondWith(
    caches.match(event.request).then((response) => {
      // Cache hit - ritorna la risposta dalla cache
      if (response) {
        return response;
      }

      // Altrimenti, vai in rete
      return fetch(event.request).then((response) => {
        // Controlla se abbiamo ricevuto una risposta valida
        if (!response || response.status !== 200 || response.type !== 'basic') {
          return response;
        }

        // Clona la risposta perché il body può essere consumato solo una volta
        const responseToCache = response.clone();

        caches.open('cinfoeat-v1').then((cache) => {
          cache.put(event.request, responseToCache);
        });

        return response;
      });
    })
  );
}); 